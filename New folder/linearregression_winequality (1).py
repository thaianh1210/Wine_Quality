# -*- coding: utf-8 -*-
"""LinearRegression_winequality.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o8N3VJsjOJxj4WusUwFJv1a3Qo5-fZBJ
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from zipfile import ZipFile

zip = ZipFile('winequality.zip')
zip.extractall()

red = pd.read_csv('/content/winequality/winequality-red.csv', sep = ';')
red

white = pd.read_csv('/content/winequality/winequality-white.csv', sep = ';')
white

red.head(5)

red.info()
white.info()

red.isnull().sum()
white.isnull().sum()

red['quality'].hist()

# Dữ liệu được phân bổ chủ yếu từ 5 cho tới 7. Do đó, ta sẽ lọc bỏ những giá trị chiếm thiểu số.

red = red[(red['quality'] > 4) & (red['quality'] < 8)]
red = red.reset_index(drop = True)

print(red['alcohol'][1])
print(red['alcohol'][100])

red['quality'].hist()

#Để loại bỏ những phần tính toán phức tạp, chúng ta có thể lọc bỏ 1 số các features không có sự tương quan mật thiết với chất lượng của rượu
#Chúng ta sẽ nhìn thấy rõ hơn bằng việc sử dụng heatmap.

red.corr()

import seaborn 
dataplot = seaborn.heatmap(red.corr(), cmap="YlGnBu", annot=True)

#Ta có thể thấy những features có giá trị thấp bao gồm: pH, density, total sulfur dioxide, free sulfur dioxide, cholorides và volatile acidity. Do đó, ta sẽ ưu tiên lọc bỏ các features này.

red =red.drop(['pH', 'density', 'total sulfur dioxide', 'free sulfur dioxide', 'chlorides', 'volatile acidity'], axis =1)
red

train_red, test_red = train_test_split(red, test_size = 0.2, random_state = 1)
#Tập train và test sẽ được chia theo tỉ lệ 80-20

train_stats =train_red.describe()
train_stats

train_red

train_Y = train_red['quality']
train_X = train_red.drop(['quality'], axis = 1)

train_Y = np.array(train_Y)
train_Y =train_Y.reshape(607, 2)

test_Y = test_red['quality']
test_X = test_red.drop(['quality'], axis = 1)

test_Y.shape
test_Y = np.array(test_Y)
test_Y = test_Y.reshape(152, 2)

from sklearn.preprocessing import MinMaxScaler
mms = MinMaxScaler()
X = mms.fit_transform(train_X)
x = mms.fit_transform(test_X)
train_Y = mms.fit_transform(train_Y)
test_Y = mms.fit_transform(test_Y)

train_Y
train_Y =train_Y.flatten()
test_Y = test_Y.flatten()

from sklearn.linear_model import LinearRegression
LR = LinearRegression()
LR.fit(X, train_Y)

#Predict
model = LR.predict(x)
model

#Calculate the MSE
from sklearn.metrics import mean_squared_error, r2_score
MSE = mean_squared_error(model, test_Y)
R2_Score = r2_score(model, test_Y)
print('MSE:', MSE)
print('R2_Score', R2_Score* 100)

